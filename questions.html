<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Matrix Terminal</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#000; }
    body {
      min-height:720px; display:flex; align-items:center; justify-content:center;
      background: radial-gradient(circle at 50% 20%, #002a2a, #000);
    }

    body.hint {
      background: radial-gradient(circle at 50% 20%, #2a0000, #000);
    }
    .crt-layout { display:flex; align-items:center; gap:16px; }
    .crt-wrap {
      position:relative; padding:0 10px 20px; border-radius:40px;
      box-shadow:0 0 50px 50px #000; background:#000; display:inline-block;
    }
    #crt-canvas { display:block; pointer-events:auto; cursor:default; }

    .qhits { position:absolute; inset:0; z-index:3; pointer-events:none; }
    .qhit {
      position:absolute; border-radius:6px; pointer-events:auto; cursor:pointer;
      background: transparent; border: none; padding: 0; margin: 0; 

    }

  </style>
</head>
<body>
  <div class="crt-layout">
    <div class="crt-wrap">
      <div class="qhits" id="qhits" aria-hidden="false"></div>
      <canvas id="crt-canvas" width="960" height="720"></canvas>
    </div>
  </div>

  <script src="https://unpkg.com/regl@2.1.0/dist/regl.js"></script>
  <script>

    const hex2vec = h => { const s=h.replace('#',''); return [parseInt(s.slice(0,2),16)/255,parseInt(s.slice(2,4),16)/255,parseInt(s.slice(4,6),16)/255]; };
    const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
    const now=()=>performance.now();

    const charW=6, charH=10, bufferCW=80, bufferCH=36; 
    const bufferW=bufferCW*charW, bufferH=bufferCH*charH;
    const textureW=512, textureH=512;

    const bufferCanvas=document.createElement('canvas'); bufferCanvas.width=bufferW; bufferCanvas.height=bufferH; const ctx=bufferCanvas.getContext('2d');

    const theCanvas = document.getElementById('crt-canvas');
    let regl; let spriteTexture; let quad; let __fallback2D=false; let __view2dCtx=null;

    const THEME = {
      default: { fg: hex2vec('#00e050'), bg: hex2vec('#000000') },
      hint:    { fg: hex2vec('#ff3b3b'), bg: hex2vec('#000000') }
    };
    try{
      regl = createREGL({ canvas: theCanvas, attributes:{antialias:true,alpha:false,preserveDrawingBuffer:true} });
      spriteTexture = regl.texture({ width:textureW, height:textureH, mag:'linear' });
    }catch(err){
      console.warn('REGL/CRT init failed, falling back to 2D', err);
      __fallback2D = true;
      __view2dCtx = theCanvas.getContext('2d');
    }

  if(!__fallback2D){
  quad = regl({
      vert:`precision mediump float; 
attribute vec2 position; 
varying vec2 uv; 
void main(){ 
  uv = position*vec2(0.5,-0.5)+vec2(0.5); 
  gl_Position=vec4(position,0.0,1.0);
}`,
  frag:`precision mediump float;
varying vec2 uv;
uniform sampler2D sprite;
uniform float time;
uniform vec3 bgColor;
uniform vec3 fgColor;
#define textureW ${textureW+'.0'}
#define textureH ${textureH+'.0'}
#define consoleW ${bufferW+'.0'}
#define consoleH ${bufferH+'.0'}
void main(){
  vec2 consoleWH=vec2(consoleW,consoleH);
  float t=time;
  float glitchLine=mod(0.8+t*0.04,1.0);
  float flutter=mod(t*32.0,1.0);
  float glitchAmt=0.02+flutter*0.005; 
  float glitchDist=0.02+flutter*0.06; 
  vec2 c=uv-0.5;
  float f=dot(c,c)*0.14; 

  vec2 duvWarp=uv+c*(1.0-f)*f;
  float band = smoothstep(0.12, 0.18, uv.y); 
  vec2 duv=mix(uv, duvWarp, band);
  vec2 fromEdge=0.5-abs(duv-0.5);
  if(fromEdge.x>0.0 && fromEdge.y>0.0){
    vec2 fromEdgePx=min(0.12*consoleWH*fromEdge, vec2(1.0)); 
    vec2 inTex=mod(duv*consoleWH*0.5, vec2(1.0));
    float distTo=glitchLine-(duv.y-inTex.y/consoleH);
    float goL=step(0.0,distTo)*max(0.0,glitchDist-distTo)/glitchDist;
    float go=goL*0.6; 
  vec2 inOff=inTex-0.5;
  float scan=inOff.y*inOff.y/0.35; 
  float intensity=6.0-scan*4.0+go*1.0; 
  vec2 uvAdj=inOff*vec2(0.0,0.35/consoleH)*band; 
  duv.x -= band*(go*glitchAmt + 0.006*(flutter*flutter*flutter)); 
    vec4 src=texture2D(sprite,(duv-uvAdj)*consoleWH/vec2(textureW,textureH));
    vec3 rgb=src.rgb*src.a;
    float fade=1.0-dot(c,c)*1.2; 
    float edge=fromEdgePx.x*fromEdgePx.y;
    gl_FragColor=vec4(edge*fade*mix(bgColor,fgColor,intensity*rgb+go*0.8)*(1.0-0.12*scan),0.16);
  } else {
    gl_FragColor=vec4(0.0,0.0,0.0,1.0);
  }
}`,
      attributes:{ position: regl.buffer([[-1,-1],[1,-1],[-1,1],[1,1]]) },
  uniforms:{ time: regl.context('time'), sprite: spriteTexture, bgColor: regl.prop('bg'), fgColor: regl.prop('fg') },
      primitive:'triangle strip', count:4, depth:{ enable:false }, blend:{ enable:true, func:{ src:'src alpha', dst:'one minus src alpha' } }
  });
  }

    const tetVerts = (()=>{ const pts=[[1,1,1],[1,-1,-1],[-1,1,-1],[-1,-1,1]]; return pts.map(([x,y,z])=>{ const L=Math.hypot(x,y,z); const s=0.9/L; return [x*s,y*s,z*s]; }); })();
    const tetEdges=[[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]];
    let tetAngle=0; const rotY=([x,y,z],a)=>{const c=Math.cos(a),s=Math.sin(a);return [c*x+s*z,y,-s*x+c*z];}; const rotX=([x,y,z],a)=>{const c=Math.cos(a),s=Math.sin(a);return [x,c*y-s*z,s*y+c*z];}; const proj=([x,y,z])=>{const f=1.4,dz=z+3.0,s=f/dz;return [x*s,y*s];};
  function drawPyramid(dt){
    tetAngle += dt*0.8; const pts = tetVerts.map(v => proj(rotX(rotY(v,tetAngle*1.1),tetAngle*0.6)));
    const cx=bufferW/2, cy=bufferH/2; ctx.save(); ctx.translate(cx, cy); ctx.scale(bufferH*0.35, bufferH*0.35); ctx.lineWidth = 1.5/(bufferH*0.35);
    const stroke = term.hintMode ? '#00ff6b' : '#ff4a4a';
    const glow = term.hintMode ? 'rgba(0,255,120,0.35)' : 'rgba(255,64,64,0.35)';
    ctx.strokeStyle = stroke; ctx.shadowColor = glow; ctx.shadowBlur=8;
    ctx.beginPath(); tetEdges.forEach(([a,b])=>{ const pa=pts[a], pb=pts[b]; ctx.moveTo(pa[0],pa[1]); ctx.lineTo(pb[0],pb[1]); }); ctx.stroke(); ctx.restore(); }
  function drawPyramidAt(x, y, scaleK, dt){
    tetAngle += dt*0.8; const pts = tetVerts.map(v => proj(rotX(rotY(v,tetAngle*1.1),tetAngle*0.6)));
    ctx.save(); ctx.translate(x, y); const s = Math.max(1, bufferH*scaleK); ctx.scale(s, s); ctx.lineWidth = 1.5/s;
    const stroke = term.hintMode ? '#00ff6b' : '#ff4a4a';
    const glow = term.hintMode ? 'rgba(0,255,120,0.35)' : 'rgba(255,64,64,0.35)';
    ctx.strokeStyle = stroke; ctx.shadowColor = glow; ctx.shadowBlur=8;
    ctx.beginPath(); tetEdges.forEach(([a,b])=>{ const pa=pts[a], pb=pts[b]; ctx.moveTo(pa[0],pa[1]); ctx.lineTo(pb[0],pb[1]); }); ctx.stroke(); ctx.restore(); }

  function getPyramidHitRect(){ const ir=innerRect(); const px=ir.x+ir.w*0.08, py=ir.y+ir.h*0.92; const s=Math.max(1, bufferH*0.14); return { x: px - s*0.6, y: py - s*0.6, w: s*1.2, h: s*1.2 }; }

    const ui = { user:'', ans:'', output:'â€”', status:'', caretOn:true, qIndex:0, qHover:-1, hover:null };

  const term = { state:'splash', revealIdx:0, revealSpeed:16, inputActive:false, inputBuffer:'', hashRevealIdx:0, hashText:'', scroll:0, scrollMax:0, scrollDrag:false, scrollGrabY:0, splashT:0, editOnly:null, hintMode:false, hintTrans:{ active:false, t:0 }, revSplash:{ active:false, t:0 }, glitchBurst:{ active:false, t:0 }, hintPrint:{ fmtIdx:0, hintIdx:0 }, hintPrintSpeed:{ fmt:48, hint:36 }, flash:{ active:false, t:0, countdown:300, duration:0.14 } };

  const DRAW_CANVAS_QBTNS = true; 
  let qBtnsH = 0;
    const L = { pad:12, lineH:16, termPad:10, get qBtnsRect(){ return { x:this.pad, y:this.pad, w:bufferW - this.pad*2, h:qBtnsH || 30 }; }, get termRect(){ const qb=this.qBtnsRect; const gap=10; return { x:this.pad, y:qb.y+qb.h+gap, w:bufferW - this.pad*2, h: bufferH - (qb.y+qb.h+gap) - this.pad }; } };
    const innerRect = ()=>({ x:L.termRect.x + L.termPad, y:L.termRect.y + L.termPad, w:L.termRect.w - 2*L.termPad, h:L.termRect.h - 2*L.termPad });

    function roundRect(r, rad=6, fill='rgba(0,18,0,0.72)', stroke='rgba(0,255,120,0.27)'){ const {x,y,w,h}=r; const rr=rad; ctx.beginPath(); ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y,x+w,y+h,rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath(); ctx.fillStyle=fill; ctx.fill(); ctx.lineWidth=1; ctx.strokeStyle=stroke; ctx.stroke(); }
  function terminalFrame(r){
    const stroke = term.hintMode ? 'rgba(255,64,64,0.28)' : 'rgba(0,255,120,0.16)';
    roundRect(r, 10, 'rgba(0,0,0,0.95)', stroke);
  }
    function wrapText(s,x,y,maxW,lineH){ const words=String(s).split(/\s+/); let line=''; for(let i=0;i<words.length;i++){ const test=line?line+' '+words[i]:words[i]; if(ctx.measureText(test).width>maxW){ ctx.fillText(line,x,y); line=words[i]; y+=lineH; } else line=test; } ctx.fillText(line,x,y); }
    function wrapMonoString(text, x0, y0, maxW, lineH){ let line=''; let y=y0; for(const ch of String(text)){ const test=line + ch; if(ctx.measureText(test).width>maxW){ ctx.fillText(line, x0, y); y+=lineH; line=ch; } else line=test; } ctx.fillText(line, x0, y); return y; }

    function drawScrollbar(){
      const ir=innerRect(); const barW=10; const track={ x: ir.x + ir.w + 6, y: ir.y, w: barW, h: ir.h };
      if(term.hintMode){
        roundRect({x:track.x-4,y:track.y-4,w:track.w+8,h:track.h+8},6,'rgba(10,0,0,0.65)','rgba(255,80,80,0.18)');
        roundRect(track,4,'rgba(26,0,0,0.65)','rgba(255,80,80,0.18)');
      } else {
        roundRect({x:track.x-4,y:track.y-4,w:track.w+8,h:track.h+8},6,'rgba(0,10,0,0.65)','rgba(0,255,120,0.18)');
        roundRect(track,4,'rgba(0,26,0,0.65)','rgba(0,255,120,0.18)');
      }
      const minKnobH=24; const ratio = ir.h / Math.max(ir.h, term.scrollMax + ir.h); const knobH=Math.max(minKnobH, Math.floor(ratio*track.h)); const travel=track.h - knobH; const pos = term.scrollMax>0 ? (term.scroll/term.scrollMax) : 0; const knobY=track.y + Math.floor(travel*pos); const knob={ x:track.x+1, y:knobY, w:track.w-2, h:knobH };
      if(term.hintMode){
        roundRect(knob,4,'rgba(60,0,0,0.95)','#ff5e5e');
        ctx.save(); ctx.strokeStyle='rgba(255,150,150,0.25)'; ctx.lineWidth=1;
      } else {
        roundRect(knob,4,'rgba(0,60,30,0.95)','#19f07b');
        ctx.save(); ctx.strokeStyle='rgba(150,255,200,0.25)'; ctx.lineWidth=1;
      }
      for(let i=1;i<3;i++){ const gy=knob.y + Math.floor((i*knob.h)/3); ctx.beginPath(); ctx.moveTo(knob.x+3,gy); ctx.lineTo(knob.x+knob.w-3,gy); ctx.stroke(); } ctx.restore(); term._scrollbar={ track, knob };
    }

    let qBtnRects = [];
    function layoutQButtons(){
      const count=Array.isArray(window.__questions)?window.__questions.length:0;
      qBtnRects=[]; if(!count){ qBtnsH=0; return; }
      const padX=10, padY=8, btnH=22, gap=8; const maxW=bufferW - L.pad*2 - padX*2;
      ctx.save(); ctx.font='12px Inconsolata, monospace';
      let x=L.pad+padX, y=L.pad+padY;
      for(let i=0;i<count;i++){
        const labelTxt = 'Q'+String(i+1);
        const tw = Math.ceil(ctx.measureText(labelTxt).width);
        const w = Math.max(28, tw + 12);
        if(x+w > L.pad+padX+maxW){ x=L.pad+padX; y+=btnH+gap; }
        qBtnRects.push({x,y,w,h:btnH,index:i});
        x+=w+gap;
      }
      ctx.restore();
      const lastY=(qBtnRects.length ? qBtnRects[qBtnRects.length-1].y : y);
      qBtnsH=(lastY - (L.pad+padY)) + (qBtnRects.length? qBtnRects[qBtnRects.length-1].h : btnH) + padY;
    }
    function drawQButtons(){
      if(!qBtnRects.length) return;
  if(term.hintMode){ roundRect(L.qBtnsRect,6,'rgba(18,0,0,0.56)','rgba(255,80,80,0.20)'); } else { roundRect(L.qBtnsRect,6,'rgba(0,18,0,0.56)','rgba(0,255,120,0.16)'); }
      ctx.save(); ctx.font='12px Inconsolata, monospace';
      for(const r of qBtnRects){
        const active=(r.index===ui.qIndex), hot=(r.index===ui.qHover);
        const fill= term.hintMode
          ? (active? 'rgba(72,0,0,0.96)' : (hot? 'rgba(62,10,10,0.9)' : 'rgba(40,0,0,0.78)'))
          : (active? 'rgba(0,72,36,0.96)' : (hot? 'rgba(10,62,34,0.9)' : 'rgba(0,40,20,0.78)'));
        const stroke= term.hintMode
          ? (active? '#ff6b6b' : (hot? '#ff5050' : '#a83a3a'))
          : (active? '#1ee38b' : (hot? '#15d06b' : '#0a8f4e'));
        roundRect(r,4,fill,stroke);
        const labelTxt='Q'+String(r.index+1);
        const tw=ctx.measureText(labelTxt).width;
        if(term.hintMode){ ctx.fillStyle='#ffd6d6'; ctx.shadowColor='rgba(255,64,64,0.35)'; }
        else { ctx.fillStyle='#eaffef'; ctx.shadowColor='rgba(0,255,100,0.35)'; }
        ctx.shadowBlur=5;
        ctx.fillText(labelTxt, r.x+(r.w-tw)/2, r.y+r.h-6);
      }
      ctx.restore();
    }

    let loadingAnim=0, loadingTarget=null; function startLoadingTransition(newIdx){ if(newIdx===ui.qIndex) return; loadingAnim=1.0; loadingTarget=newIdx; }

  const canvas = theCanvas;
    const toBuf=(e)=>{ const r=canvas.getBoundingClientRect(); return { x:(e.clientX-r.left)*(bufferW/canvas.width), y:(e.clientY-r.top)*(bufferH/canvas.height) }; };
    const ptIn=(r,p)=> p.x>=r.x && p.x<=r.x+r.w && p.y>=r.y && p.y<=r.y+r.h;

    async function generateHash(){ try{ let out; if(window.GitWorkshop && typeof window.GitWorkshop.generateFinalHash === 'function'){ out=await window.GitWorkshop.generateFinalHash(ui.user.trim(), ui.ans.trim()); } else if(window.crypto?.subtle){ const enc=new TextEncoder(); const buf=await crypto.subtle.digest('SHA-256', enc.encode(ui.user.trim()+':'+ui.ans.trim())); out=Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join(''); } else { out=ui.user.trim()+':'+ui.ans.trim(); } const textOut=(out && typeof out==='object' && 'output' in out)? out.output : (out || 'â€”'); ui.output=textOut; ui.status='hash generated'; return textOut; } catch(e){ ui.status='hash error'; console.error(e); return 'â€”'; } }
    async function copyOutput(){ try{ await navigator.clipboard.writeText(String(ui.output||'')); ui.status='copied'; } catch{ ui.status='copy failed'; } }
    window.copyOutput = copyOutput;

  let copyBtnRect=null; let copyBtnHot=false;
  let userEditBtnRect=null; let userEditHot=false;
  let ansEditBtnRect=null; let ansEditHot=false;

  let videoLinkRect=null; let videoLinkHot=false; let videoLinkHref='';
  let imageLinkRect=null; let imageLinkHot=false; let imageLinkHref='';
  let hintCopyRect=null; let hintCopyHot=false; let hintCopyValue='';
  canvas.addEventListener('mousemove', e=>{
    const p=toBuf(e);
    layoutQButtons(); ui.qHover=-1;
    if(DRAW_CANVAS_QBTNS && term.state!=='splash' && !term.revSplash?.active && !term.glitchBurst?.active){
      for(const r of qBtnRects){ if(ptIn(r,p)){ ui.qHover=r.index; break; } }
    }
    const ir=innerRect();
    const overTerm=ptIn({x:ir.x,y:ir.y,w:ir.w+20,h:ir.h},p);
    const textMode=overTerm && (term.state==='promptUser' || term.state==='promptAnswer');
    const overKnob = term._scrollbar && ptIn(term._scrollbar.knob, p);
    copyBtnHot = copyBtnRect ? ptIn(copyBtnRect,p) : false;
    userEditHot = userEditBtnRect ? ptIn(userEditBtnRect,p) : false;
    ansEditHot = ansEditBtnRect ? ptIn(ansEditBtnRect,p) : false;
    const overPyr = (!term.revSplash?.active && !term.glitchBurst?.active && term.state!=='splash') && ptIn(getPyramidHitRect(), p);
    const copyEnabled = (term.state==='showHash' || term.state==='done') && ui.output && ui.output!=='â€”';
    const overCopy = copyEnabled && copyBtnHot;
    const overUserEdit = userEditHot;
    const overAnsEdit = ansEditHot;
  const overVideo = videoLinkRect ? ptIn(videoLinkRect, p) : false; videoLinkHot = overVideo;
  const overImage = imageLinkRect ? ptIn(imageLinkRect, p) : false; imageLinkHot = overImage;
  const overHintCopy = hintCopyRect ? ptIn(hintCopyRect, p) : false; hintCopyHot = overHintCopy;
    ui.hover = (term.revSplash?.active || term.glitchBurst?.active) ? null : (
      (ui.qHover!==-1) ? 'qbtn' : (
        overPyr ? 'hintToggle' : (
          overKnob ? 'scroll' : (
            overCopy ? 'copy' : (
              overUserEdit ? 'editUser' : (
                overAnsEdit ? 'editAns' : (
                  overVideo ? 'video' : (
                    overImage ? 'image' : (
                      overHintCopy ? 'hintCopy' : null
                    )
                  )
                )
              )
            )
          )
        )
      )
    );
    canvas.style.cursor = term.scrollDrag ? 'grabbing' : (
      (term.revSplash?.active || term.glitchBurst?.active) ? 'default' : (
        textMode ? 'text' : (
          ui.hover==='scroll' ? 'grab' : (
            ui.hover ? 'pointer' : 'default'
          )
        )
      )
    );
    if(term.scrollDrag){ const { track, knob } = term._scrollbar || {}; if(track){ const clampedY = clamp(p.y - term.scrollGrabY, track.y, track.y + track.h - knob.h); const travel = track.h - knob.h; const pos = (clampedY - track.y) / (travel || 1); term.scroll = Math.round(pos * term.scrollMax); } }
  });
    function toggleHintMode(){

      if(term.revSplash?.active || term.glitchBurst?.active) return;
      term.hintMode = !term.hintMode; 
      loadingAnim = 1.0; 
      term.revSplash = { active:true, t:0 };
      term.glitchBurst = { active:false, t:0 };

      term.hintTrans = { active:false, t:0 };

      try { document.body.classList.toggle('hint', term.hintMode); } catch {}

      try { ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,bufferW,bufferH); ctx.restore(); } catch {}

      try { fadeCountdown = 0; } catch {}

      try { term.hintPrint = { fmtIdx:0, hintIdx:0 }; } catch {}
    }
    canvas.addEventListener('mousedown', e=>{ const p=toBuf(e); layoutQButtons();
      if(term.revSplash?.active || term.glitchBurst?.active){ return; }

      if(term.state!=='splash' && ptIn(getPyramidHitRect(), p)){ toggleHintMode(); return; }
  if(copyBtnRect){ const enabled=(term.state==='showHash' || term.state==='done') && ui.output && ui.output!=='â€”'; if(enabled && ptIn(copyBtnRect,p)){ copyOutput(); return; } }

  if(videoLinkRect && ptIn(videoLinkRect,p) && videoLinkHref){ try{ window.open(String(videoLinkHref), '_blank', 'noopener'); } catch {} return; }
      if(imageLinkRect && ptIn(imageLinkRect,p) && imageLinkHref){ try{ window.open(String(imageLinkHref), '_blank', 'noopener'); } catch {} return; }
      if(hintCopyRect && ptIn(hintCopyRect,p) && hintCopyValue){
        (async()=>{ try{ await navigator.clipboard.writeText(String(hintCopyValue)); ui.status='copied'; } catch{ ui.status='copy failed'; } })();
        return;
      }
      if(userEditBtnRect && ptIn(userEditBtnRect,p)){
        term.state='promptUser'; term.inputActive=true; term.inputBuffer=String(ui.user||''); term.editOnly='user'; return;
      }
      if(ansEditBtnRect && ptIn(ansEditBtnRect,p)){
        term.state='promptAnswer'; term.inputActive=true; term.inputBuffer=String(ui.ans||''); term.editOnly='ans'; return;
      }
      if(DRAW_CANVAS_QBTNS && term.state!=='splash'){
        for(const r of qBtnRects){ if(ptIn(r,p)){ startLoadingTransition(r.index); return; } }
      }
      const ir=innerRect(); const { track, knob } = term._scrollbar || {};
      if(track && (ptIn(knob,p) || ptIn(track,p))){ term.scrollDrag=true; term.scrollGrabY=p.y - knob.y; return; }
      if(ptIn(ir,p) && (term.state==='promptUser' || term.state==='promptAnswer')){ term.inputActive=true; } else { term.inputActive=false; }
    });
  window.addEventListener('mouseup', ()=>{ term.scrollDrag=false; });
  canvas.addEventListener('wheel', e=>{ if(term.revSplash?.active || term.glitchBurst?.active) return; const p=toBuf(e); const ir=innerRect(); const over=ptIn({x:ir.x,y:ir.y,w:ir.w+20,h:ir.h},p); if(!over) return; e.preventDefault(); const delta=Math.sign(e.deltaY)*24; term.scroll=clamp(term.scroll + delta, 0, term.scrollMax); }, { passive:false });

  window.addEventListener('keydown', async e=>{ if(term.revSplash?.active || term.glitchBurst?.active) return; if(!(term.state==='promptUser' || term.state==='promptAnswer')) return; if(!term.inputActive) return; const field = term.state==='promptUser' ? 'user' : 'ans'; if(e.key==='Backspace'){ term.inputBuffer=term.inputBuffer.slice(0,-1); e.preventDefault(); return; } if(e.key==='Escape'){ term.inputBuffer=''; term.inputActive=false; term.state = (ui.output && ui.output!=='â€”') ? 'showHash' : 'showQuestion'; term.editOnly=null; return; } if(e.key==='Enter'){ ui[field]=term.inputBuffer.trim(); term.inputBuffer=''; term.inputActive=false; if(term.editOnly){

          if(field==='user'){
            if(ui.ans){ term.state='hashing'; const out=await generateHash(); term.hashRevealIdx=0; term.hashText=String(out||'â€”'); term.state='showHash'; }
            else { term.state='promptAnswer'; term.inputActive=true; }
          } else { 
            if(ui.user){ term.state='hashing'; const out=await generateHash(); term.hashRevealIdx=0; term.hashText=String(out||'â€”'); term.state='showHash'; }
            else { term.state='promptUser'; term.inputActive=true; }
          }
          term.editOnly=null; return;
        }

        if(field==='user'){ term.state='promptAnswer'; term.inputActive=true; }
        else { term.state='hashing'; const out=await generateHash(); term.hashRevealIdx=0; term.hashText=String(out||'â€”'); term.state='showHash'; }
        return; }
      if(e.key.length===1){ const c=e.key.charCodeAt(0); if(c>=32 && c<=126) term.inputBuffer+=e.key; } });

    window.questionText='Loading questions...';

    let lastHitsSig = '';
    function updateQHits(){ const hits = document.getElementById('qhits'); if(!hits) return; const wrap = document.querySelector('.crt-wrap'); const cRect = theCanvas.getBoundingClientRect(); const wRect = wrap.getBoundingClientRect(); const sx = cRect.width / bufferW; const sy = cRect.height / bufferH; const offX = cRect.left - wRect.left; const offY = cRect.top - wRect.top; const sig = JSON.stringify(qBtnRects);
      if(sig === lastHitsSig) return; lastHitsSig = sig;
      hits.innerHTML = '';

  hits.style.pointerEvents = 'none';
      qBtnRects.forEach((r,i)=>{ const btn = document.createElement('button'); btn.className='qhit'; btn.setAttribute('aria-label', 'Question '+(i+1)); btn.style.left = (offX + r.x*sx) + 'px'; btn.style.top = (offY + r.y*sy) + 'px'; btn.style.width = (r.w*sx) + 'px'; btn.style.height = (r.h*sy) + 'px'; btn.addEventListener('click', ()=> startLoadingTransition(i)); hits.appendChild(btn); });
    }
    window.addEventListener('resize', ()=>{ lastHitsSig=''; updateQHits(); });
    (function loadQuestions(){ if (window.GitWorkshop && typeof window.GitWorkshop.loadAndDecryptQuestions === 'function'){ window.GitWorkshop.loadAndDecryptQuestions().then(qs=>{ try{ if(Array.isArray(qs) && qs.length){ window.__questions=qs; setupQuestion(0); } else window.questionText='No questions found'; }catch(e){ window.questionText='Question parse error'; } }).catch(()=>{ window.questionText='Failed to load questions'; }); } else { setTimeout(loadQuestions, 500); } })();
  function setupQuestion(idx){ ui.qIndex=idx|0; const q = Array.isArray(window.__questions) && window.__questions[ui.qIndex] || null; const text=(q && (q.question || q.text || q.title || JSON.stringify(q))) || String(window.questionText||'No question'); window.questionText=text; ui.user=''; ui.ans=''; ui.output='â€”'; ui.status=''; if(term.state!=='splash') term.state='showQuestion'; term.revealIdx=0; term.inputActive=false; term.inputBuffer=''; term.hashRevealIdx=0; term.hashText=''; term.scroll=0; term.scrollMax=0; }

    let last=now(), fadeCountdown=0, caretTimer=0;
    function frame(){
      const t=now(); const dt=Math.min(0.05,(t-last)/1000); last=t;
  fadeCountdown -= dt; if(fadeCountdown < 0){ ctx.fillStyle = term.hintMode ? 'rgba(20,0,0,0.92)' : 'rgba(0,20,0,0.9)'; ctx.fillRect(0,0,bufferW,bufferH); fadeCountdown += 0.06; }
      caretTimer += dt; if(caretTimer>0.5){ ui.caretOn=!ui.caretOn; caretTimer=0; }

  terminalFrame(L.termRect);
  if(term.state!=='splash'){
    if(!term.revSplash?.active && !term.glitchBurst?.active){
      layoutQButtons(); if(DRAW_CANVAS_QBTNS) drawQButtons(); updateQHits();
    } else {

      const hits = document.getElementById('qhits'); if(hits){ hits.innerHTML=''; }
    }
  }

      const ir=innerRect();

      if(term.state!=='splash' && !term.revSplash?.active && !term.glitchBurst?.active){
        if(!term.flash.active){
          term.flash.countdown -= dt;
          if(term.flash.countdown <= 0){ term.flash.active = true; term.flash.t = 0; term.flash.countdown = 300; }
        } else {
          term.flash.t += dt;
          if(term.flash.t >= (term.flash.duration||0.14)){ term.flash.active = false; }
        }
      }

      if(term.state==='splash'){
        term.splashT += dt;
        const center={x:ir.x+ir.w*0.5, y:ir.y+ir.h*0.5};

        const dest={x:ir.x+ir.w*0.08, y:ir.y+ir.h*0.92};
        const t0=1.2, t1=2.2;
        let pos=center, scale=0.28, titleAlpha=1.0;
        if(term.splashT < t0){ titleAlpha = Math.min(1, term.splashT/0.5); }
        else if(term.splashT < t1){ const u=(term.splashT - t0)/(t1 - t0); const s=u*u*(3-2*u); pos={ x:center.x + (dest.x - center.x)*s, y:center.y + (dest.y - center.y)*s }; scale=0.36 + (0.18-0.36)*s; titleAlpha = 1.0 - s; }
        else { pos=dest; scale=0.14; titleAlpha=0; term.state='showQuestion'; }
        if(!term.glitchBurst?.active){
          drawPyramidAt(pos.x, pos.y, scale, dt);
        }
        if(titleAlpha>0){ ctx.save(); ctx.globalAlpha=titleAlpha; ctx.font='28px Inconsolata, monospace'; ctx.fillStyle='#ccffe4'; ctx.shadowColor='rgba(0,255,120,0.25)'; ctx.shadowBlur=10; const label='MCGUCKET LABS'; const tw=ctx.measureText(label).width; ctx.fillText(label, ir.x+(ir.w-tw)/2, ir.y+ir.h*0.25); ctx.restore(); }
      } else {

        const center={x:ir.x+ir.w*0.5, y:ir.y+ir.h*0.5};
        const dest={x:ir.x+ir.w*0.08, y:ir.y+ir.h*0.92};
        let pos=dest, scale=0.14;
        if(term.revSplash?.active){

          const u = Math.max(0, Math.min(1, term.revSplash.t/1.0)); 
          const s = u*u*(3-2*u); 
          pos = { x: dest.x + (center.x - dest.x) * s, y: dest.y + (center.y - dest.y) * s };
          scale = 0.14 + (0.28 - 0.14) * s;

          const titleAlpha = Math.min(1, term.revSplash.t / 0.5);
          ctx.save();
          ctx.globalAlpha = titleAlpha;
          ctx.font='28px Inconsolata, monospace';
          ctx.fillStyle= term.hintMode ? '#ffd6d6' : '#ccffe4';
          ctx.shadowColor= term.hintMode ? 'rgba(255,64,64,0.25)' : 'rgba(0,255,120,0.25)';
          ctx.shadowBlur=10;
          const label='MCGUCKET LABS'; const tw=ctx.measureText(label).width;
          ctx.fillText(label, ir.x+(ir.w-tw)/2, ir.y+ir.h*0.25);
          ctx.restore();
        }
        drawPyramidAt(pos.x, pos.y, scale, dt);
      }

      ctx.save(); ctx.beginPath(); ctx.rect(ir.x, ir.y, ir.w, ir.h); ctx.clip();
  ctx.font='12px Inconsolata, monospace'; if(term.hintMode){ ctx.fillStyle='#ffc8c8'; ctx.shadowColor='rgba(255,64,64,0.14)'; } else { ctx.fillStyle='#8df2a4'; ctx.shadowColor='rgba(0,255,120,0.10)'; } ctx.shadowBlur=2;
  const tx=ir.x+6, ty0=ir.y+8; const tmaxW=ir.w-12; const lineH=14; let y=ty0 - term.scroll;
      if(loadingAnim > 0){ const alpha=Math.abs(Math.cos(Math.PI*loadingAnim)); ctx.globalAlpha=0.3 + 0.7*alpha; }

      videoLinkRect = null; videoLinkHref = '';
      imageLinkRect = null; imageLinkHref = '';
      hintCopyRect = null; hintCopyValue = '';
      if(!term.revSplash?.active && !term.glitchBurst?.active){
        const qobj = (Array.isArray(window.__questions) && window.__questions[ui.qIndex]) || null;
        const href = qobj && (qobj.videoUrl || qobj.video || qobj.link);
        if(href){
          const label = 'â–¶ Watch video';
          ctx.save();
          ctx.font='12px Inconsolata, monospace';

          if(term.hintMode){ ctx.fillStyle = '#ffd6d6'; ctx.shadowColor='rgba(255,64,64,0.18)'; }
          else { ctx.fillStyle = '#a6f2d6'; ctx.shadowColor='rgba(0,255,120,0.12)'; }
          ctx.shadowBlur=3;
          ctx.fillText(label, tx, y);
          const tw = ctx.measureText(label).width;

          ctx.beginPath(); ctx.moveTo(tx, y+2); ctx.lineTo(tx+tw, y+2);
          ctx.strokeStyle = term.hintMode ? '#ff9a9a' : '#15d06b'; ctx.lineWidth=1; ctx.stroke();
          ctx.restore();
          videoLinkRect = { x: tx-2, y: y-12, w: tw+4, h: lineH };
          videoLinkHref = String(href);
          y += lineH + 8;
        }

        const imgHref = qobj && (qobj.imageUrl || qobj.image || qobj.img);
        if(imgHref){
          const label = 'ðŸ–¼ View image';
          ctx.save();
          ctx.font='12px Inconsolata, monospace';
          if(term.hintMode){ ctx.fillStyle = '#ffd6d6'; ctx.shadowColor='rgba(255,64,64,0.18)'; }
          else { ctx.fillStyle = '#a6f2d6'; ctx.shadowColor='rgba(0,255,120,0.12)'; }
          ctx.shadowBlur=3;
          ctx.fillText(label, tx, y);
          const tw = ctx.measureText(label).width;
          ctx.beginPath(); ctx.moveTo(tx, y+2); ctx.lineTo(tx+tw, y+2);
          ctx.strokeStyle = term.hintMode ? '#ff9a9a' : '#15d06b'; ctx.lineWidth=1; ctx.stroke();
          ctx.restore();
          imageLinkRect = { x: tx-2, y: y-12, w: tw+4, h: lineH };
          imageLinkHref = String(imgHref);
          y += lineH + 8;
        }
      }

      const qAll=String(window.questionText||''); const qWords=qAll.split(/\s+/); if(term.state==='loading') term.state='showQuestion';
      if(term.state!=='splash' && !term.revSplash?.active && !term.glitchBurst?.active){
        if(!term.hintMode){
          if(term.state==='showQuestion'){ term.revealIdx += term.revealSpeed * dt; const shown=Math.floor(term.revealIdx); const shownText=qWords.slice(0, clamp(shown,0,qWords.length)).join(' '); wrapText(shownText, tx, y, tmaxW, lineH); if(shown>=qWords.length){ term.state='promptUser'; term.inputActive=true; } }
          else { wrapText(qAll, tx, y, tmaxW, lineH); }
        }
      }
      const measureWrapHeight=(s)=>{ const words=String(s).split(/\s+/); let line=''; let lines=1; for(let i=0;i<words.length;i++){ const test=line?line+' '+words[i]:words[i]; if(ctx.measureText(test).width>tmaxW){ line=words[i]; lines++; } else line=test; } return lines*lineH; };
      if(!term.revSplash?.active && !term.glitchBurst?.active){
        const qH = term.hintMode ? 0 : measureWrapHeight(term.state==='showQuestion' ? qWords.slice(0, Math.min(qWords.length, Math.floor(term.revealIdx))).join(' ') : qAll);
        y += qH + 10;
      }

      if(term.state!=='splash' && term.hintMode && !term.revSplash?.active && !term.glitchBurst?.active){
  const q = (Array.isArray(window.__questions) && window.__questions[ui.qIndex]) || null;
        const hasHint = q && typeof q.hint === 'string' && q.hint.trim().length > 0;
        const fmt = (q && (q.format || q.answerFormat)) || 'string';
        const spacer = 6;

        const hintFull = hasHint ? ('Hint: ' + String(q.hint||'')) : '';
        const fmtFull  = 'Format: ' + String(fmt);

        term.hintPrint.fmtIdx += (term.hintPrintSpeed?.fmt || 48) * dt;
        if(hasHint) term.hintPrint.hintIdx += (term.hintPrintSpeed?.hint || 36) * dt;
        const hintShown = hasHint ? hintFull.slice(0, Math.floor(term.hintPrint.hintIdx)) : '';
        const fmtShown  = fmtFull.slice(0, Math.floor(term.hintPrint.fmtIdx));

        let yPanel = y + 8; let panelH = 0;
        ctx.save();
        ctx.font='12px Inconsolata, monospace';
  ctx.fillStyle = '#ffd6d6';
  ctx.shadowColor='rgba(255,64,64,0.25)'; ctx.shadowBlur=6;
        if(hasHint){ wrapText(hintShown, tx, yPanel, tmaxW, lineH); const hH = measureWrapHeight(hintShown || ''); yPanel += hH + spacer; }
        wrapText(fmtShown, tx, yPanel, tmaxW, lineH); yPanel += lineH;

        const copyVal = (q && (q.copyText || q.copy || q.copyString)) || '';
        if(String(copyVal).trim().length){
          const label = 'Copy:';
          ctx.fillStyle='#ffd6d6';
          ctx.shadowColor='rgba(255,64,64,0.25)';
          ctx.shadowBlur=6;
          ctx.fillText(label, tx, yPanel);
          const lx = tx + ctx.measureText(label + ' ').width;

          ctx.fillStyle='#ffecec';
          const endY = wrapMonoString(String(copyVal), lx, yPanel, tmaxW - (lx - tx) - 60, lineH);

          const btnW=48, btnH=16; const bx = ir.x + ir.w - btnW - 8; const by = endY - 12;
          const hover = hintCopyHot;
          const fillBtn = hover? 'rgba(62,10,10,0.9)' : 'rgba(40,0,0,0.78)';
          const strokeBtn = hover? '#ff5050' : '#a83a3a';
          roundRect({x:bx,y:by,w:btnW,h:btnH},4,fillBtn,strokeBtn);
          ctx.save(); ctx.font='11px Inconsolata, monospace'; ctx.fillStyle='#ffdede'; const bl='COPY'; const btw=ctx.measureText(bl).width; ctx.fillText(bl, bx+(btnW-btw)/2, by+btnH-4); ctx.restore();
          hintCopyRect = { x:bx, y:by, w:btnW, h:btnH };
          hintCopyValue = String(copyVal);

          yPanel = Math.max(endY + spacer, by + btnH + spacer);
        } else { hintCopyRect = null; hintCopyValue=''; }

        ctx.restore();
        panelH = (yPanel - y) + 6; y += panelH;
      }

  if(!term.revSplash?.active && !term.glitchBurst?.active && term.state!=='splash' && (term.state==='promptUser' || term.state==='promptAnswer' || term.state==='hashing' || term.state==='showHash' || term.state==='done')){
  const colLabel = term.hintMode ? '#ffb8b8' : '#98e9bb';
  const colValue = term.hintMode ? '#ffdede' : '#dbfbe6';
  const colCaret = term.hintMode ? '#ff9a9a' : '#88e3a8';
    ctx.fillStyle=colLabel; ctx.fillText('> GitHub username:', tx, y);
        const ux = tx + ctx.measureText('> GitHub username: ').width; const uname=(term.state==='promptUser') ? term.inputBuffer : (ui.user||'');
    ctx.fillStyle=colValue; ctx.fillText(uname, ux, y);
    if(term.state==='promptUser' && ui.caretOn){ const w=ctx.measureText(uname).width; ctx.beginPath(); ctx.moveTo(ux+w+1, y-12); ctx.lineTo(ux+w+1, y+4); ctx.strokeStyle=colCaret; ctx.lineWidth=1; ctx.stroke(); }

        if(term.state!=='promptUser'){
          const btnW=44, btnH=16; const bx = ir.x + ir.w - btnW - 20; const by = y - 12; userEditBtnRect = {x:bx,y:by,w:btnW,h:btnH}; const hover=userEditHot;
          const fill = term.hintMode ? (hover? 'rgba(62,10,10,0.9)' : 'rgba(40,0,0,0.78)') : (hover? 'rgba(10,62,34,0.9)' : 'rgba(0,40,20,0.78)');
          const stroke = term.hintMode ? (hover? '#ff5050' : '#a83a3a') : (hover? '#15d06b' : '#0a8f4e');
          roundRect(userEditBtnRect,4,fill,stroke); ctx.save(); ctx.font='11px Inconsolata, monospace'; ctx.fillStyle= term.hintMode ? '#ffdede' : '#d8ffe6'; const label='EDIT'; const tw=ctx.measureText(label).width; ctx.fillText(label, bx+(btnW-tw)/2, by+btnH-4); ctx.restore();
        } else { userEditBtnRect=null; }
        y += lineH + 4;

  ctx.fillStyle=colLabel; ctx.fillText('> Answer:', tx, y);
        const ax = tx + ctx.measureText('> Answer: ').width; const answerShown=(term.state==='promptAnswer') ? term.inputBuffer : (ui.ans||''); ctx.fillStyle='#eaffef';
        const drawInlineWrap=(text, x0, y0)=>{ const words=String(text).split(/\s+/); let line=''; let yy=y0; for(let i=0;i<words.length;i++){ const word=(line?line+' ':'') + words[i]; if(ctx.measureText(word).width > (tmaxW - (x0 - tx))){ ctx.fillText(line, x0, yy); yy+=lineH; line=words[i]; } else line=word; } ctx.fillText(line, x0, yy); return { lastY: yy, lastLineWidth: ctx.measureText(line).width }; };
        const wrapRes = drawInlineWrap(answerShown, ax, y);
  if(term.state==='promptAnswer' && ui.caretOn){ ctx.beginPath(); ctx.moveTo(ax + wrapRes.lastLineWidth + 1, wrapRes.lastY-12); ctx.lineTo(ax + wrapRes.lastLineWidth + 1, wrapRes.lastY+4); ctx.strokeStyle=colCaret; ctx.lineWidth=1; ctx.stroke(); }

        if(term.state!=='promptAnswer'){
          const btnW=44, btnH=16; const bx = ir.x + ir.w - btnW - 20; const by = (wrapRes.lastY - 12); ansEditBtnRect = {x:bx,y:by,w:btnW,h:btnH}; const hover=ansEditHot;
          const fill2 = term.hintMode ? (hover? 'rgba(62,10,10,0.9)' : 'rgba(40,0,0,0.78)') : (hover? 'rgba(10,62,34,0.9)' : 'rgba(0,40,20,0.78)');
            const stroke2 = term.hintMode ? (hover? '#ff5050' : '#0aa85a'.replace('#0aa85a','#a83a3a')) : (hover? '#15d06b' : '#0a8f4e');
          roundRect(ansEditBtnRect,4,fill2,stroke2); ctx.save(); ctx.font='11px Inconsolata, monospace'; ctx.fillStyle= term.hintMode ? '#ffdede' : '#d8ffe6'; const label='EDIT'; const tw=ctx.measureText(label).width; ctx.fillText(label, bx+(btnW-tw)/2, by+btnH-4); ctx.restore();
        } else { ansEditBtnRect=null; }
        y = wrapRes.lastY + lineH + 6;

        if(term.state==='showHash' || term.state==='done'){
          ctx.fillStyle=colLabel; ctx.fillText('> Hash:', tx, y);
          const hx = tx + ctx.measureText('> Hash: ').width;
          if(term.state==='showHash'){ term.hashRevealIdx += 48 * dt; if(term.hashRevealIdx >= (term.hashText||'').length){ term.hashRevealIdx=(term.hashText||'').length; term.state='done'; } }
          const shownHash=(term.hashText||'').slice(0, Math.floor(term.hashRevealIdx));
          ctx.fillStyle=colValue; wrapMonoString(shownHash, hx, y, tmaxW - (hx - tx), lineH);
          const hashLines = Math.ceil(ctx.measureText(shownHash).width / Math.max(1, (tmaxW - (hx - tx))));
          y += Math.max(lineH, hashLines*lineH);
        }
      }

      const totalHeight = y - (ty0 - term.scroll);
      term.scrollMax = Math.max(0, totalHeight - ir.h);
      term.scroll = clamp(term.scroll, 0, term.scrollMax);

      if(term.flash.active && !term.revSplash?.active && !term.glitchBurst?.active){
        const cx = ir.x + ir.w*0.5, cy = ir.y + ir.h*0.5;
        ctx.save();
        ctx.font = '14px Inconsolata, monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
  if(term.hintMode){ ctx.fillStyle='#ffdede'; ctx.shadowColor='rgba(255,64,64,0.5)'; }
  else { ctx.fillStyle='#c8f5dc'; ctx.shadowColor='rgba(0,255,120,0.4)'; }
        ctx.shadowBlur=12;
        const msg = 'i wonder what happens if i click this';
        ctx.fillText(msg, cx, cy);
        ctx.restore();
      }

  ctx.globalAlpha = 1.0; ctx.restore();

      if(term.state!=='splash' && !term.revSplash?.active && !term.glitchBurst?.active){
        drawScrollbar();

        (function(){ const btnW=96, btnH=20; const x=ir.x+ir.w-btnW-4, y=ir.y+ir.h-btnH-4; copyBtnRect={x,y,w:btnW,h:btnH}; const enabled=(term.state==='showHash'||term.state==='done') && ui.output && ui.output!=='â€”'; const hover=copyBtnHot && enabled; let fill, stroke, textCol; if(term.hintMode){ fill = enabled ? (hover?'rgba(70,8,8,0.95)':'rgba(48,6,6,0.9)') : 'rgba(24,24,24,0.5)'; stroke = enabled ? (hover?'#ff6b6b':'#c64a4a') : 'rgba(120,80,80,0.6)'; textCol = enabled ? '#ffdede' : '#a07d7d'; } else { fill = enabled ? (hover?'rgba(8,70,36,0.95)':'rgba(6,48,28,0.9)') : 'rgba(8,8,8,0.5)'; stroke = enabled ? (hover?'#29ff9a':'#18c67a') : 'rgba(80,120,90,0.6)'; textCol = enabled ? '#d8ffe6' : '#7da08b'; } roundRect(copyBtnRect,4,fill,stroke); ctx.save(); ctx.font='11px Inconsolata, monospace'; ctx.fillStyle=textCol; const label='COPY HASH'; const tw=ctx.measureText(label).width; ctx.fillText(label, x+(btnW-tw)/2, y+btnH-5); ctx.restore(); })();
      }

  if(loadingAnim > 0){ loadingAnim -= dt*2.2; if(loadingAnim <= 0 && loadingTarget !== null){ setupQuestion(loadingTarget); loadingTarget = null; } }

  if(term.revSplash?.active){
    term.revSplash.t += dt*1.5;
    if(term.revSplash.t >= 1){
      term.revSplash.active=false;
      term.glitchBurst = { active:true, t:0 };
    }
  }

  if(term.glitchBurst?.active){
    term.glitchBurst.t += dt;

    const duration = 0.6; 
    const phase = clamp(term.glitchBurst.t/duration, 0, 1);
    const flashes = 4;
    const baseAlpha = 0.25 + 0.5*Math.sin(phase*10.0);
    ctx.save();

    ctx.globalAlpha = 0.35; ctx.fillStyle = '#ff2a3a'; ctx.fillRect(0,0,bufferW,bufferH);

    for(let i=0;i<12;i++){
      const y0 = Math.floor(Math.random()*bufferH);
      const h  = 2 + Math.floor(Math.random()*8);
      ctx.globalAlpha = 0.12 + Math.random()*0.25;
      ctx.fillStyle = Math.random()<0.5 ? '#ffffff' : '#ff8080';
      ctx.fillRect(0, y0, bufferW, h);
    }

    for(let i=0;i<80;i++){
      ctx.globalAlpha = 0.06 + Math.random()*0.18;
      ctx.fillStyle = '#ffd0d0';
      const w = 4+Math.floor(Math.random()*24);
      const h = 2+Math.floor(Math.random()*10);
      const x = Math.floor(Math.random()*(bufferW-w));
      const y = Math.floor(Math.random()*(bufferH-h));
      ctx.fillRect(x,y,w,h);
    }

    for(let f=0; f<flashes; f++){
      const a = Math.max(0, 1.0 - Math.abs(phase - f/flashes)*3.0);
      if(a>0.01){ ctx.globalAlpha = 0.05*a; ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,bufferW,bufferH); }
    }
    ctx.restore();
    if(term.glitchBurst.t >= duration){
      term.glitchBurst.active = false;

      term.state = term.hintMode ? 'promptUser' : 'showQuestion';
      term.revealIdx=0;
      term.inputActive= !!term.hintMode;
      term.inputBuffer='';
      term.scroll=0; term.scrollMax=0;

      try { ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,bufferW,bufferH); ctx.restore(); } catch {}
      fadeCountdown = 0;

      try { term.hintPrint = { fmtIdx:0, hintIdx:0 }; } catch {}
    }
  }

  if(ui.status && !term.revSplash?.active && !term.glitchBurst?.active){ ctx.save(); ctx.font='12px Inconsolata, monospace'; ctx.fillStyle='#caffd3'; ctx.shadowColor='rgba(0,255,120,0.18)'; ctx.shadowBlur=3; ctx.fillText(ui.status, L.termRect.x + 8, L.termRect.y + L.termRect.h - 8); ctx.restore(); }

      if(__fallback2D){

        const dc = canvas; const g = __view2dCtx; if(g){
          g.save();
          g.imageSmoothingEnabled = false;
          g.clearRect(0,0,dc.width,dc.height);
          const scale = Math.min(dc.width/bufferW, dc.height/bufferH);
          const dw = Math.floor(bufferW*scale), dh = Math.floor(bufferH*scale);
          const dx = Math.floor((dc.width - dw)/2), dy = Math.floor((dc.height - dh)/2);
          g.drawImage(bufferCanvas, dx, dy, dw, dh);
          g.restore();
        }
        requestAnimationFrame(frame);
      } else {

  if(term.hintMode && term.glitchBurst?.active){ ctx.save(); ctx.globalAlpha = 0.28; ctx.fillStyle = '#ff2a3a'; ctx.fillRect(0,0,bufferW,bufferH); ctx.restore(); }
        regl.poll(); spriteTexture.subimage(bufferCanvas, 0, 0);
        const theme = term.hintMode ? THEME.hint : THEME.default;
        quad({ bg: theme.bg, fg: theme.fg }); requestAnimationFrame(frame);
      }
    }
    frame();
  </script>
  <script src="script.js"></script>
  <script></script>
</body>
</html>